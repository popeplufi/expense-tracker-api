{% extends "base.html" %}

{% block title %}Chats{% endblock %}

{% block content %}
<section class="section">
    <div class="chat-layout whatsapp-layout">
        <aside class="card chat-sidebar whatsapp-sidebar">
            <header class="whatsapp-sidebar__top">
                <div>
                    <p class="mb-0 text-secondary small">Signed in as</p>
                    <h6 class="mb-0">@{{ g.user.username }}</h6>
                </div>
                <a href="{{ url_for('main.settings_page') }}" class="btn btn-outline-secondary btn-sm">Settings</a>
            </header>

            <div class="whatsapp-sidebar__search">
                <input
                    id="userSearchInput"
                    type="text"
                    class="form-control"
                    placeholder="Search friends..."
                    autocomplete="off"
                >
            </div>

            <div class="chat-list" id="chatList">
                {% if chats %}
                    {% for chat in chats %}
                    <a
                        href="{{ url_for('main.chat_home', chat=chat.id) }}"
                        class="chat-list-item {% if active_chat_id == chat.id %}chat-list-item--active{% endif %}"
                        data-chat-id="{{ chat.id }}"
                        data-chat-name="{{ (chat.peer_username or chat.name or 'Chat') | lower }}"
                    >
                        <div class="chat-list-item__title-row">
                            <div class="chat-list-item__title">{{ chat.peer_username or chat.name or "Chat" }}</div>
                            {% if chat.unread_count and chat.unread_count > 0 %}
                            <span class="chat-unread-badge" data-unread-badge="{{ chat.id }}">{{ chat.unread_count }}</span>
                            {% endif %}
                        </div>
                        <div class="chat-list-item__meta">{{ chat.last_message or "No messages yet" }}</div>
                    </a>
                    {% endfor %}
                {% else %}
                    <p class="text-secondary small mb-0">No chats yet. Start one from contacts.</p>
                {% endif %}
            </div>

            <h6 class="mt-4 mb-2">Start Chat</h6>
            <div class="chat-contacts" id="userList">
                {% if ai_bot %}
                <a
                    href="{{ url_for('main.start_ai_bot_chat') }}"
                    class="chat-contact-item chat-contact-item--bot"
                >
                    {{ ai_bot.username }} (AI)
                </a>
                {% endif %}
                {% if users %}
                    {% for user in users %}
                    <a
                        href="{{ url_for('main.start_direct_chat', user_id=user.id) }}"
                        class="chat-contact-item"
                        data-user-name="{{ user.username | lower }}"
                    >
                        {{ user.username }}
                    </a>
                    {% endfor %}
                {% else %}
                    <p class="text-secondary small mb-0">No other users found.</p>
                {% endif %}
            </div>
        </aside>

        <section class="card chat-window whatsapp-chat-window">
            {% if active_chat %}
            <header class="chat-window__header whatsapp-chat-header">
                <div class="chat-window__header-main">
                    <p class="text-secondary small mb-0">Chat</p>
                    <h5 class="mb-0">Conversation</h5>
                </div>
                <div class="call-actions">
                    <button id="audioCallBtn" type="button" class="btn btn-outline-secondary btn-sm">Call</button>
                    <button id="videoCallBtn" type="button" class="btn btn-primary btn-sm">Video</button>
                </div>
            </header>

            <div class="chat-window__messages" id="chatMessages">
                {% if messages %}
                    {% for message in messages %}
                    <article class="message-row {% if message.sender_id == g.user.id %}message-row--me{% endif %}" data-message-id="{{ message.id }}">
                        <div class="message-bubble {% if message.sender_id == g.user.id %}message-bubble--me{% endif %}">
                            <p class="message-text mb-1">{{ message.body }}</p>
                            <p class="message-meta mb-0">
                                {{ message.sender_username }} · {{ message.created_at }}
                                {% if message.sender_id == g.user.id %}
                                <span class="message-tick">{% if message.is_seen %}✓✓{% else %}✓{% endif %}</span>
                                {% endif %}
                            </p>
                        </div>
                    </article>
                    {% endfor %}
                {% else %}
                    <p class="text-secondary mb-0">No messages yet. Say hello.</p>
                {% endif %}
            </div>
            <div id="typingIndicator" class="typing-indicator"></div>
            {% if ai_bot and active_chat_peer and active_chat_peer == ai_bot.username %}
            <section class="ai-prompt-bar">
                <button type="button" class="btn btn-outline-secondary btn-sm ai-prompt-btn" data-prompt="Summarize the last messages and give action points.">Summarize</button>
                <button type="button" class="btn btn-outline-secondary btn-sm ai-prompt-btn" data-prompt="Help me write a clear reply to the conversation.">Write reply</button>
                <button type="button" class="btn btn-outline-secondary btn-sm ai-prompt-btn" data-prompt="Create a step-by-step plan for my goal.">Plan</button>
            </section>
            {% endif %}
            <section id="callPanel" class="call-panel d-none">
                <div class="call-panel__status" id="callStatus">Not in call</div>
                <div class="call-panel__videos">
                    <video id="remoteVideo" class="call-video call-video--remote" autoplay playsinline></video>
                    <video id="localVideo" class="call-video call-video--local" autoplay playsinline muted></video>
                </div>
                <div class="call-panel__actions">
                    <button id="muteCallBtn" type="button" class="btn btn-outline-secondary btn-sm">Mute</button>
                    <button id="endCallBtn" type="button" class="btn btn-danger btn-sm">End</button>
                </div>
            </section>
            <section id="incomingCallBanner" class="incoming-call-banner d-none">
                <p id="incomingCallText" class="mb-2 fw-semibold">Incoming call...</p>
                <div class="d-flex gap-2">
                    <button id="acceptCallBtn" type="button" class="btn btn-primary btn-sm">Accept</button>
                    <button id="rejectCallBtn" type="button" class="btn btn-outline-secondary btn-sm">Reject</button>
                </div>
            </section>

            <form method="post" action="{{ url_for('main.send_chat_message', chat_id=active_chat.id) }}" class="chat-window__composer whatsapp-composer" id="chatComposer">
                <input type="text" class="form-control" name="body" placeholder="Type a message..." autocomplete="off" required>
                <button type="submit" class="btn btn-primary">Send</button>
            </form>
            {% else %}
            <div class="chat-window__empty">
                <h5>No chat selected</h5>
                <p class="text-secondary mb-0">Choose a chat from the left or start a new one.</p>
            </div>
            {% endif %}
        </section>
    </div>
</section>
{% endblock %}

{% block scripts %}
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<script>
const container = document.getElementById("chatMessages");
if (container) {
    container.scrollTop = container.scrollHeight;
}

const ACTIVE_CHAT_ID = {{ active_chat_id | tojson }};
const CURRENT_USER_ID = {{ g.user.id | tojson }};
const CURRENT_USERNAME = {{ g.user.username | tojson }};
const chatList = document.getElementById("chatList");
const composer = document.getElementById("chatComposer");
const messageInput = composer ? composer.querySelector("input[name='body']") : null;
const userSearchInput = document.getElementById("userSearchInput");
const userList = document.getElementById("userList");
const typingIndicator = document.getElementById("typingIndicator");
const audioCallBtn = document.getElementById("audioCallBtn");
const videoCallBtn = document.getElementById("videoCallBtn");
const endCallBtn = document.getElementById("endCallBtn");
const muteCallBtn = document.getElementById("muteCallBtn");
const callPanel = document.getElementById("callPanel");
const callStatus = document.getElementById("callStatus");
const remoteVideo = document.getElementById("remoteVideo");
const localVideo = document.getElementById("localVideo");
const incomingCallBanner = document.getElementById("incomingCallBanner");
const incomingCallText = document.getElementById("incomingCallText");
const acceptCallBtn = document.getElementById("acceptCallBtn");
const rejectCallBtn = document.getElementById("rejectCallBtn");
const aiPromptButtons = document.querySelectorAll(".ai-prompt-btn");
const socket = io({ transports: ["websocket", "polling"] });
let typingState = false;
let typingStopTimer = null;
let pushReady = false;
let peerConnection = null;
let localStream = null;
let remoteStream = null;
let pendingOffer = null;
let callMode = "audio";
let isMuted = false;
const optimisticMessages = new Map();
const rtcConfig = {
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
};

function maybeNotify(message) {
    if (!message) return;
    if (pushReady) return;
    if (Number(message.sender_id) === Number(CURRENT_USER_ID)) return;
    if (document.visibilityState === "visible" && document.hasFocus()) return;
    if (!("Notification" in window) || Notification.permission !== "granted") return;
    new Notification(message.sender_username || "New message", {
        body: message.body || "",
        tag: `chat_${message.chat_id}`
    });
}

function urlBase64ToUint8Array(base64String) {
    const padding = "=".repeat((4 - (base64String.length % 4)) % 4);
    const base64 = (base64String + padding).replace(/\-/g, "+").replace(/_/g, "/");
    const rawData = atob(base64);
    const outputArray = new Uint8Array(rawData.length);
    for (let i = 0; i < rawData.length; i += 1) {
        outputArray[i] = rawData.charCodeAt(i);
    }
    return outputArray;
}

async function registerPushNotifications() {
    if (!("serviceWorker" in navigator) || !("PushManager" in window)) return;
    try {
        const registration = await navigator.serviceWorker.register("/static/sw.js");
        const keyResponse = await fetch("/api/push/public-key", { credentials: "same-origin" });
        const keyPayload = await keyResponse.json();
        if (!keyPayload || !keyPayload.ok || !keyPayload.public_key) return;

        let subscription = await registration.pushManager.getSubscription();
        if (!subscription) {
            const permission = await Notification.requestPermission();
            if (permission !== "granted") return;
            subscription = await registration.pushManager.subscribe({
                userVisibleOnly: true,
                applicationServerKey: urlBase64ToUint8Array(keyPayload.public_key),
            });
        }
        await fetch("/api/push/subscribe", {
            method: "POST",
            credentials: "same-origin",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(subscription.toJSON()),
        });
        pushReady = true;
    } catch (_err) {
        pushReady = false;
    }
}

function escapeHtml(value) {
    return String(value)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/\"/g, "&quot;")
        .replace(/'/g, "&#039;");
}

function updateUnreadSummary(summary) {
    if (!chatList || !summary || !Array.isArray(summary.items)) return;

    const unreadByChat = new Map();
    summary.items.forEach((item) => {
        const chatId = Number(item.chat_id);
        unreadByChat.set(chatId, Number(item.unread_count || 0));
    });

    chatList.querySelectorAll(".chat-list-item[data-chat-id]").forEach((item) => {
        const chatId = Number(item.getAttribute("data-chat-id"));
        const unreadCount = unreadByChat.get(chatId) || 0;
        const titleRow = item.querySelector(".chat-list-item__title-row");
        if (!titleRow) return;
        let badge = titleRow.querySelector(".chat-unread-badge");
        if (unreadCount <= 0) {
            if (badge) badge.remove();
            return;
        }
        if (!badge) {
            badge = document.createElement("span");
            badge.className = "chat-unread-badge";
            badge.setAttribute("data-unread-badge", String(chatId));
            titleRow.appendChild(badge);
        }
        badge.textContent = String(unreadCount);
    });

    const total = Number(summary.total_unread || 0);
    document.title = total > 0 ? `(${total}) Chats` : "Chats";
}

function renderOptimisticMessage(clientMsgId, body) {
    if (!container || !clientMsgId) return;
    const row = document.createElement("article");
    row.className = "message-row message-row--me";
    row.setAttribute("data-client-message-id", clientMsgId);
    row.innerHTML = `
        <div class="message-bubble message-bubble--me">
            <p class="message-text mb-1">${escapeHtml(body)}</p>
            <p class="message-meta mb-0">
                ${escapeHtml(CURRENT_USERNAME)} · sending...
                <span class="message-tick">...</span>
            </p>
        </div>
    `;
    container.appendChild(row);
    container.scrollTop = container.scrollHeight;
}

function renderMessage(message) {
    if (!container) return;
    if (!message || Number(message.chat_id) !== Number(ACTIVE_CHAT_ID)) return;
    if (container.querySelector(`[data-message-id=\"${message.id}\"]`)) return;

    const mine = Number(message.sender_id) === Number(CURRENT_USER_ID);
    const row = document.createElement("article");
    row.className = `message-row${mine ? " message-row--me" : ""}`;
    row.setAttribute("data-message-id", String(message.id));
    row.innerHTML = `
        <div class="message-bubble${mine ? " message-bubble--me" : ""}">
            <p class="message-text mb-1">${escapeHtml(message.body)}</p>
            <p class="message-meta mb-0">
                ${escapeHtml(message.sender_username)} · ${escapeHtml(message.created_at)}
                ${mine ? `<span class="message-tick">${message.is_seen ? "✓✓" : "✓"}</span>` : ""}
            </p>
        </div>
    `;
    container.appendChild(row);
    container.scrollTop = container.scrollHeight;
    if (!mine && ACTIVE_CHAT_ID) {
        socket.emit("mark_seen", { room: `conversation_${ACTIVE_CHAT_ID}` });
    }
}

function setTypingIndicator(text = "") {
    if (!typingIndicator) return;
    typingIndicator.textContent = text;
}

function setCallStatus(text) {
    if (callStatus) {
        callStatus.textContent = text || "";
    }
}

function showCallPanel(show) {
    if (!callPanel) return;
    callPanel.classList.toggle("d-none", !show);
}

function showIncomingBanner(show, text = "Incoming call...") {
    if (!incomingCallBanner) return;
    if (incomingCallText) incomingCallText.textContent = text;
    incomingCallBanner.classList.toggle("d-none", !show);
}

async function ensureLocalStream(mode) {
    if (localStream) return localStream;
    localStream = await navigator.mediaDevices.getUserMedia({
        audio: true,
        video: mode === "video"
    });
    if (localVideo) {
        localVideo.srcObject = localStream;
    }
    return localStream;
}

function stopLocalStream() {
    if (!localStream) return;
    localStream.getTracks().forEach((track) => track.stop());
    localStream = null;
    if (localVideo) localVideo.srcObject = null;
}

function cleanupPeerConnection() {
    if (peerConnection) {
        peerConnection.onicecandidate = null;
        peerConnection.ontrack = null;
        peerConnection.close();
    }
    peerConnection = null;
    remoteStream = null;
    if (remoteVideo) remoteVideo.srcObject = null;
}

async function createPeerConnection(mode) {
    cleanupPeerConnection();
    peerConnection = new RTCPeerConnection(rtcConfig);
    remoteStream = new MediaStream();
    if (remoteVideo) {
        remoteVideo.srcObject = remoteStream;
    }

    peerConnection.onicecandidate = (event) => {
        if (!event.candidate || !ACTIVE_CHAT_ID) return;
        socket.emit("call_ice_candidate", {
            room: `conversation_${ACTIVE_CHAT_ID}`,
            candidate: event.candidate
        });
    };

    peerConnection.ontrack = (event) => {
        event.streams[0].getTracks().forEach((track) => remoteStream.addTrack(track));
    };

    const stream = await ensureLocalStream(mode);
    stream.getTracks().forEach((track) => peerConnection.addTrack(track, stream));
    showCallPanel(true);
    return peerConnection;
}

async function startOutgoingCall(mode) {
    if (!ACTIVE_CHAT_ID) return;
    if (!navigator.mediaDevices || !window.RTCPeerConnection) {
        alert("Calling is not supported in this browser.");
        return;
    }
    callMode = mode;
    setCallStatus(mode === "video" ? "Starting video call..." : "Starting voice call...");
    await createPeerConnection(mode);
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    socket.emit("call_offer", {
        room: `conversation_${ACTIVE_CHAT_ID}`,
        offer,
        call_type: mode
    });
    setCallStatus("Calling...");
}

async function acceptIncomingCall() {
    if (!pendingOffer || !ACTIVE_CHAT_ID) return;
    const mode = pendingOffer.call_type === "video" ? "video" : "audio";
    callMode = mode;
    showIncomingBanner(false);
    setCallStatus(mode === "video" ? "Joining video call..." : "Joining voice call...");
    await createPeerConnection(mode);
    await peerConnection.setRemoteDescription(new RTCSessionDescription(pendingOffer.offer));
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    socket.emit("call_answer", {
        room: `conversation_${ACTIVE_CHAT_ID}`,
        answer
    });
    pendingOffer = null;
    setCallStatus("In call");
}

function endCall(notifyPeer = true) {
    if (notifyPeer && ACTIVE_CHAT_ID) {
        socket.emit("call_end", { room: `conversation_${ACTIVE_CHAT_ID}` });
    }
    pendingOffer = null;
    showIncomingBanner(false);
    showCallPanel(false);
    setCallStatus("Call ended");
    cleanupPeerConnection();
    stopLocalStream();
    isMuted = false;
    if (muteCallBtn) muteCallBtn.textContent = "Mute";
}

socket.on("connect", () => {
    if (ACTIVE_CHAT_ID) {
        socket.emit("join_chat", { room: `conversation_${ACTIVE_CHAT_ID}` });
        socket.emit("mark_seen", { room: `conversation_${ACTIVE_CHAT_ID}` });
    }
});

socket.on("new_message", (message) => {
    renderMessage(message);
    maybeNotify(message);
});
socket.on("receive_message", (message) => {
    renderMessage(message);
    maybeNotify(message);
});
socket.on("message_sent", (payload) => {
    if (!payload || !payload.message) return;
    const clientMsgId = payload.client_msg_id ? String(payload.client_msg_id) : null;
    if (clientMsgId) {
        optimisticMessages.delete(clientMsgId);
        const pendingRow = container
            ? container.querySelector(`[data-client-message-id="${clientMsgId}"]`)
            : null;
        if (pendingRow) pendingRow.remove();
    }
    renderMessage(payload.message);
});
socket.on("unread_summary", (summary) => {
    updateUnreadSummary(summary);
});
socket.on("socket_error", (err) => {
    const message = (err && err.message) ? String(err.message) : "Action failed.";
    if (typingIndicator) {
        typingIndicator.textContent = message;
        window.setTimeout(() => {
            if (typingIndicator.textContent === message) {
                typingIndicator.textContent = "";
            }
        }, 2200);
    }
});

socket.on("typing_start", (event) => {
    if (!event || Number(event.chat_id) !== Number(ACTIVE_CHAT_ID)) return;
    if (Number(event.user_id) === Number(CURRENT_USER_ID)) return;
    setTypingIndicator(`${event.username || "Someone"} is typing...`);
});

socket.on("typing_stop", (event) => {
    if (!event || Number(event.chat_id) !== Number(ACTIVE_CHAT_ID)) return;
    setTypingIndicator("");
});

socket.on("messages_seen", (payload) => {
    if (!payload || Number(payload.chat_id) !== Number(ACTIVE_CHAT_ID)) return;
    const ids = new Set((payload.message_ids || []).map((id) => String(id)));
    if (!ids.size) return;
    ids.forEach((id) => {
        const row = container ? container.querySelector(`[data-message-id="${id}"]`) : null;
        if (!row) return;
        const tick = row.querySelector(".message-tick");
        if (tick) tick.textContent = "✓✓";
    });
});

socket.on("call_offer", async (payload) => {
    if (!payload || Number(payload.chat_id) !== Number(ACTIVE_CHAT_ID)) return;
    if (!payload.offer) return;
    pendingOffer = payload;
    const label = payload.call_type === "video" ? "video call" : "voice call";
    showIncomingBanner(true, `${payload.sender_username || "Someone"} is calling (${label})`);
    setCallStatus("Incoming call...");
});

socket.on("call_answer", async (payload) => {
    if (!payload || Number(payload.chat_id) !== Number(ACTIVE_CHAT_ID)) return;
    if (!peerConnection || !payload.answer) return;
    await peerConnection.setRemoteDescription(new RTCSessionDescription(payload.answer));
    setCallStatus("In call");
});

socket.on("call_ice_candidate", async (payload) => {
    if (!payload || Number(payload.chat_id) !== Number(ACTIVE_CHAT_ID)) return;
    if (!peerConnection || !payload.candidate) return;
    try {
        await peerConnection.addIceCandidate(new RTCIceCandidate(payload.candidate));
    } catch (_err) {
        // Ignore transient ICE race conditions.
    }
});

socket.on("call_end", (payload) => {
    if (!payload || Number(payload.chat_id) !== Number(ACTIVE_CHAT_ID)) return;
    endCall(false);
    setCallStatus("Peer ended the call");
});

if (composer && messageInput && ACTIVE_CHAT_ID) {
    messageInput.addEventListener("input", () => {
        if (!typingState) {
            typingState = true;
            socket.emit("typing_start", { room: `conversation_${ACTIVE_CHAT_ID}` });
        }
        if (typingStopTimer) {
            window.clearTimeout(typingStopTimer);
        }
        typingStopTimer = window.setTimeout(() => {
            typingState = false;
            socket.emit("typing_stop", { room: `conversation_${ACTIVE_CHAT_ID}` });
        }, 900);
    });

    messageInput.addEventListener("blur", () => {
        if (!typingState) return;
        typingState = false;
        socket.emit("typing_stop", { room: `conversation_${ACTIVE_CHAT_ID}` });
    });

    composer.addEventListener("submit", (event) => {
        event.preventDefault();
        const body = messageInput.value.trim();
        if (!body) return;
        const clientMsgId = `c_${Date.now()}_${Math.random().toString(36).slice(2, 10)}`;
        optimisticMessages.set(clientMsgId, { body, createdAt: Date.now() });
        renderOptimisticMessage(clientMsgId, body);
        socket.emit("send_message", {
            room: `conversation_${ACTIVE_CHAT_ID}`,
            body,
            sender: CURRENT_USERNAME,
            client_msg_id: clientMsgId,
        });
        window.setTimeout(() => {
            if (!optimisticMessages.has(clientMsgId)) return;
            optimisticMessages.delete(clientMsgId);
            const pendingRow = container
                ? container.querySelector(`[data-client-message-id="${clientMsgId}"]`)
                : null;
            if (!pendingRow) return;
            const tick = pendingRow.querySelector(".message-tick");
            if (tick) tick.textContent = "!";
            const meta = pendingRow.querySelector(".message-meta");
            if (meta) meta.textContent = `${CURRENT_USERNAME} · failed to send`;
        }, 12000);
        messageInput.value = "";
        if (typingState) {
            typingState = false;
            socket.emit("typing_stop", { room: `conversation_${ACTIVE_CHAT_ID}` });
        }
    });
}

if (userSearchInput && userList) {
    userSearchInput.addEventListener("input", () => {
        const query = userSearchInput.value.trim().toLowerCase();
        const items = userList.querySelectorAll(".chat-contact-item");
        items.forEach((item) => {
            const name = item.getAttribute("data-user-name") || "";
            item.style.display = name.includes(query) ? "" : "none";
        });
    });
}

if (aiPromptButtons && messageInput) {
    aiPromptButtons.forEach((btn) => {
        btn.addEventListener("click", () => {
            const prompt = btn.getAttribute("data-prompt") || "";
            messageInput.value = prompt;
            messageInput.focus();
        });
    });
}

if (audioCallBtn && ACTIVE_CHAT_ID) {
    audioCallBtn.addEventListener("click", () => {
        startOutgoingCall("audio").catch(() => setCallStatus("Unable to start call"));
    });
}

if (videoCallBtn && ACTIVE_CHAT_ID) {
    videoCallBtn.addEventListener("click", () => {
        startOutgoingCall("video").catch(() => setCallStatus("Unable to start call"));
    });
}

if (acceptCallBtn) {
    acceptCallBtn.addEventListener("click", () => {
        acceptIncomingCall().catch(() => setCallStatus("Unable to join call"));
    });
}

if (rejectCallBtn) {
    rejectCallBtn.addEventListener("click", () => {
        showIncomingBanner(false);
        pendingOffer = null;
        if (ACTIVE_CHAT_ID) {
            socket.emit("call_end", { room: `conversation_${ACTIVE_CHAT_ID}` });
        }
        setCallStatus("Call rejected");
    });
}

if (endCallBtn) {
    endCallBtn.addEventListener("click", () => {
        endCall(true);
    });
}

if (muteCallBtn) {
    muteCallBtn.addEventListener("click", () => {
        if (!localStream) return;
        isMuted = !isMuted;
        localStream.getAudioTracks().forEach((track) => {
            track.enabled = !isMuted;
        });
        muteCallBtn.textContent = isMuted ? "Unmute" : "Mute";
    });
}

window.addEventListener("beforeunload", () => {
    if (peerConnection || localStream) {
        endCall(true);
    }
});

if ("Notification" in window && Notification.permission === "default") {
    Notification.requestPermission().catch(() => {});
}
registerPushNotifications();
</script>
{% endblock %}
